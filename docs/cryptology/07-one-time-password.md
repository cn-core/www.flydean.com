[toc]

# 一次性密码本

一次性密码本即Vernam Cipher，是由Gilbert Vernam在1917年， 开发的一种加密算法。

之所以叫做一次性密码本，是因为加密所用的密钥是一次性的，即密钥只会使用一次，不会出现因为密钥泄露导致之前的加密内容被解密。

即使密钥被泄露了，也只会影响一次通信过程。

# 加密之前的准备

通常来说，如果我们想将一个消息加密传输需要做什么工作呢？

在现代计算机社会，大家都知道计算机只能表示0，1这两个数字，那么如果传输文字，则需要将文字转换为对应的二进制编码。

现有的编码规则有很多，比如：ASCII，Unicode等，在后续的文章中我们会做介绍。

同样的，对于编码过后的文字进行加密，就是将编码过后文字的二进制通过一定的bit运算，而得到加密后的结果。

# 一次性密码本的加密方式

回到一次性密码本，他的加密方式非常简单，就是将明文和一串随机的二进制进行XOR运算。这个随机的二进制数可以通过不断的抛掷硬币来产生（正面表示1，反面表示0）：

1. 将明文编码，即转换为二进制。
2. 生成和明文二进制位数相同的密钥。
3. 将明文和密钥的二进制进行XOR操作，生成最后结果。

# 一次性密码本的解密

加密之后我们怎么去做解密呢？ 我们先看一下XOR的特性。

XOR是指异或操作，比特位上的数字一样，异或的结果就是0，比特为上面的数字不一样，异或的结果就是1。

举个例子：
0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0

异或的一个非常重要的特性就是可逆，即：
A XOR B= C ，则  C XOR B = A 。

那么通过原文和密钥异或得到的结果，可以通过将结果和密钥再次异或操作得到原文。

这就是一次性密码本的解密过程：将密钥和结果进行异或。

# 无法破译

虽然一次性密码本非常简单，但是一次性密码本是无法破译的，这个破译并不是指现有的计算能力不够，而是指即使拥有无穷大的计算能力也无法破译。

为什么呢？ 

假如你拿到了加密的结果，然后遍历等长的密钥进行暴力破解，最后你会生成原文，假设这个原文长度是128bit，那么就可以生成2的128次方个原文，即128bit长度的原文的所有组合排列。

即使这些组合里面出现了一些有意义的文字，但是你不能确定这些文字是不是就是原文，因为在所有的组合排列中可能生成多个有意义的文字。

所以这种解密是无意义的，就像是我知道了原文的长度，然后自己构造这个长度的原文。

# 缺陷

既然一次性密码本这么好，那么为什么我们在实际的工作中很少用到呢？

1. 密钥太长

一次性密码本是用与原文等长的密钥做异或得到的，如果原文很大，那么相应的密钥也非常大。

2. 无法重用密钥

每个密钥只用一次，即是缺点也是优点。意味着我们每次都要不停的更换密钥，增加了复杂性。

3. 密钥的配送

因为密钥和原文以及密文都是等长的，目标端如果想解密就必须拿到密钥，如果能够机密的传输密钥给目标端，那为什么不直接将原文机密的传送给目标端呢？ 

4. 密钥的保存

每次加密都需要换一个密钥，这意味着每一个明文都需要保存一个同样长度的密钥，如果明文已经可以很好的保存了，那何必多做一步加密呢？ 

虽然一次性密码本有这么多缺点，但是他给其他的加密算法以启发，于是产生了很多个变种，后面我们会介绍更多的加密算法。

更多教程请参考 [flydean的博客](http://www.flydean.com/one-time-password/)