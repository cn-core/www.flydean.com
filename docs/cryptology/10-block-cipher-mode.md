分组密码与模式

[toc]

## 什么是分组密码和模式

前面我们讲过了DES和AES算法，他们每次都只能加密固定长度的明文，这样的密码算法叫做分组密码。

如果需要加密更长的明文则需要对分组密码进行迭代。而分组密码的迭代方法就称为分组密码的模式。

本文我们会讲如下几种模式：

* ECB模式：电子密码本模式
* CBC模式： 密码分组链接模式
* CFB模式： 密文反馈模式
* OFB模式： 输出反馈模式
* CTR模式： 计数器模式

## ECB模式

ECB模式的全称是Electronic CodeBook模式，ECB模式是将明文分组（分组密码算法中作为加密对象的明文）加密之后的结果直接成为密文分组（使用分组加密算法将明文分组加密之后所生成的密文）。

下图为ECB模式的加密：

~~~mermaid
graph TD;
id1[明文分组1]
id2(加密)
id3[密文分组1]
id1-->id2
id2-->id3

id4[明文分组2]
id5(加密)
id6[密文分组2]
id4-->id5
id5-->id6

id7[明文分组3]
id8(加密)
id9[密文分组3]
id7-->id8
id8-->id9

subgraph 明文
id1
id4
id7
end

subgraph 密文
id3
id6
id9
end
~~~

下图为ECB模式的解密：

~~~mermaid
graph TD;
id1[密文分组1]
id2(解密)
id3[明文分组2]
id1-->id2
id2-->id3

id4[密文分组2]
id5(解密)
id6[明文分组2]
id4-->id5
id5-->id6

id7[密文分组2]
id8(解密)
id9[明文分组2]
id7-->id8
id8-->id9

subgraph 密文
id1
id4
id7
end

subgraph 明文
id3
id6
id9
end
~~~

**ECB模式的特点**

ECB模式是最简单的模式，在其中明文和密文是一一对应的，相同的明文会被加密为相同的密文，这样可以通过观察密文得到明文中重复的组合，并以此为线索来破解密码。

**ECB模式的攻击**

ECB模式中，每个明文对应着相应的密文。 那么攻击者并不需要进行解密，他可以伪造密文的顺序，从而改变了解密出来的明文顺序。

比如 A 转账给B C元。如果A，B，C是明文分组，其对应的密文分组是a,b,c， 则攻击者只需要改变密文的顺序为：b,a,c, 那么被解密出来的明文含义就是 B转账给A  C元。

## CBC模式

CBC模式的全称是Cipher Block Chaining模式。

CBC模式是将前一个密文分组与当前的明文分组的内容混合起来进行加密的模式。这样可以避免ECB模式的弱点。

CBC模式的加密：

~~~mermaid
graph TD;
id00[初始化向量]
id11[明文分组1]
id14{XOR}
id12(加密)
id13[密文分组1]
id11-->id14
id14-->id12
id12-->id13
id00-->id14

id21[明文分组2]
id24{XOR}
id22(加密)
id23[密文分组2]
id21-->id24
id24-->id22
id22-->id23

id31[明文分组3]
id34{XOR}
id32(加密)
id33[密文分组3]
id31-->id34
id34-->id32
id32-->id33


subgraph 明文
id11
id21
id31
end

subgraph 密文
id13
id23
id33
end

id13-->id24
id23-->id34

~~~

CBC模式的解密：

~~~mermaid
graph TD;
id00[初始化向量]
id11[明文分组1]
id14{XOR}
id12(解密)
id13[密文分组1]
id14-->id11
id12-->id14
id13-->id12
id00-->id14

id21[明文分组2]
id24{XOR}
id22(解密)
id23[密文分组2]
id24-->id21
id22-->id24
id23-->id22

id31[明文分组3]
id34{XOR}
id32(解密)
id33[密文分组3]
id34-->id31
id32-->id34
id33-->id32


subgraph 明文
id11
id21
id31
end

subgraph 密文
id13
id23
id33
end

id13-->id24
id23-->id34

~~~

**CBC模式的特点**

和ECB模式相比，ECB只是进行了加密，而CBC则是在加密之前做了一次XOR。

并且CBC要与前面一个密文分组进行XOR运算，这样相同的明文分组也会生成不同的密文。ECB的缺陷就不存在了。

这样其实也是CBC的缺点，它是一个链式结构，如果要生成密文分组3，则必须先加密明文分组1，2 。 不能并行进行。

另外我们观察CBC的解密过程可以看到，如果一个密文分组损坏，只要密文长度不变，则只会影响其相关联的两个明文分组的解密。

SSL/TLS 协议就是使用CBC模式来保证通信的机密性的。

**CBC模式的攻击**

CBC模式可以操纵解密过程的初始化向量，从而对解密后的明文进行攻击。具体来说就是对初始化向量进行反转，从而导致XOR之后的明文分组1也被反转了。

另外还有一种攻击叫做填充提示攻击，如果在分组密码中，明文长度不是分组长度的整数倍时候，需要在最后一个分组填充一些数据让其凑够一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送都修改填充的数据，从而根据解密的错误信息来推断一部分明文相关的信息。

## CFB模式

CFB模式的全称是 Cipher FeedBack模式（密文反馈模式）。在CFB模式中，前一个密文分组会首先进行加密，然后再与明文分组进行XOR运算，最后得到密文分组。

如下图所示CFB模式的加密：

~~~mermaid
graph TD;
id00[初始化向量]
id11[明文分组1]
id14{XOR}
id12(加密)
id13[密文分组1]
id11-->id14
id12-->id14
id14-->id13
id00-->id12

id21[明文分组2]
id24{XOR}
id22(加密)
id23[密文分组2]
id21-->id24
id22-->id24
id24-->id23

id31[明文分组3]
id34{XOR}
id32(加密)
id33[密文分组3]
id31-->id34
id32-->id34
id34-->id33


subgraph 明文
id11
id21
id31
end

subgraph 密文
id13
id23
id33
end

id13-->id22
id23-->id32

~~~

下面是CFB模式的解密：

~~~mermaid
graph TD;
id00[初始化向量]
id11[明文分组1]
id14{XOR}
id12(加密,不是解密)
id13[密文分组1]
id14-->id11
id12-->id14
id13-->id14
id00-->id12

id21[明文分组2]
id24{XOR}
id22(加密,不是解密)
id23[密文分组2]
id24-->id21
id22-->id24
id23-->id24

id31[明文分组3]
id34{XOR}
id32(加密,不是解密)
id33[密文分组3]
id34-->id31
id32-->id34
id33-->id34


subgraph 明文
id11
id21
id31
end

subgraph 密文
id13
id23
id33
end

id13-->id22
id23-->id32

~~~

**CFB模式的攻击**

我们观察在CFB解密阶段，是通过密文加密之后和密文进行XOR操作得到明文的。

这样就有可能进行重放攻击。比如用户可以将上一次发送过来的密文保存起来，将下一次发送过来的密文进行替换，从而达到修改新明文的目的。

## OFB模式

OFB模式的全称是Output-FeedBack模式（输出反馈模式）。在OFB模式中，密码的输出会反馈到密码算法的输入中。

OFB模式是通过将明文分组和密码算法的输出进行XOR运算来产生密文分组的。

OFB模式的加密过程：

~~~mermaid

graph TD;
初始化向量-->加密1
加密1-->加密2
加密2-->加密3
加密1-->XOR1
明文分组1-->XOR1
XOR1-->密文分组1
加密2-->XOR2
明文分组2-->XOR2
XOR2-->密文分组2
加密3-->XOR3
明文分组3-->XOR3
XOR3-->密文分组3

subgraph 明文
明文分组1
明文分组2
明文分组3
end
subgraph 密文
密文分组1
密文分组2
密文分组3
end

~~~

OFB模式的解密：
~~~mermaid

graph TD;
初始化向量-->加密1
加密1-->加密2
加密2-->加密3
加密1-->XOR1
XOR1-->明文分组1
密文分组1-->XOR1
加密2-->XOR2
XOR2-->明文分组2
密文分组2-->XOR2
加密3-->XOR3
XOR3-->明文分组3
密文分组3-->XOR3

subgraph 明文
明文分组1
明文分组2
明文分组3
end
subgraph 密文
密文分组1
密文分组2
密文分组3
end
~~~

我们可以看到，OFB是将初始化向量不断的加密从而得到后续的加密输入。

他和CFB模式的区别也就在这里。CFB是将密文分组当做加密输入。

因为OFB模式中加密输入跟要加密的数据无关，所以我们可以提前计算出来所有要用到的加密输入，从而提高效率。

## CTR模式

CTR模式的全称是Counter模式(计数器模式)。CTR模式是一种将计数器不断累加，然后进行加密从而生成密钥流的流密码。

下面是CTR模式的加密：

~~~mermaid
graph TD;
计数器CTR-->加密1
加密1-->XOR1
明文分组1-->XOR1
XOR1-->密文分组1

计数器CTR+1-->加密2
加密2-->XOR2
明文分组2-->XOR2
XOR2-->密文分组2

计数器CTR+2-->加密3
加密3-->XOR3
明文分组3-->XOR3
XOR3-->密文分组3

subgraph 明文
明文分组1
明文分组2
明文分组3
end
subgraph 密文
密文分组1
密文分组2
密文分组3
end

~~~

CTR模式的解密：

~~~mermaid
graph TD;
计数器CTR-->加密1
加密1-->XOR1
XOR1-->明文分组1
密文分组1-->XOR1

计数器CTR+1-->加密2
加密2-->XOR2
XOR2-->明文分组2
密文分组2-->XOR2

计数器CTR+2-->加密3
加密3-->XOR3
XOR3-->明文分组3
密文分组3-->XOR3

subgraph 明文
明文分组1
明文分组2
明文分组3
end
subgraph 密文
密文分组1
密文分组2
密文分组3
end

~~~

**CTR模式的特点**

CTR的加密和解密使用了完全相同的结构，所以在程序设计上比较容易实现。

CTR 可以任意顺序对分组进行加密和解密，从而支持并行计算。

更多教程请参考 [flydean的博客](http://www.flydean.com/block-cipher-mode/)





